#[cfg(any(feature = "trace", feature = "os"))]
use chrono::DateTime;
#[cfg(any(feature = "trace", feature = "os"))]
use chrono::Local;
#[cfg(any(feature = "trace", feature = "os"))]
use prettytable::Cell;
#[cfg(any(feature = "trace", feature = "os"))]
use prettytable::Row;
#[cfg(any(feature = "trace", feature = "os"))]
use prettytable::Table;
#[cfg(any(feature = "trace", feature = "os"))]
use prettytable::row;
/// Code obtained by analyzing the traffic generated by the Linux `traceroute` command.
#[cfg(any(feature = "trace", feature = "os"))]
use rand::RngExt;
#[cfg(any(feature = "trace", feature = "os"))]
use std::fmt;
#[cfg(any(feature = "trace", feature = "os"))]
use std::net::IpAddr;
#[cfg(any(feature = "trace", feature = "os"))]
use std::time::Duration;
#[cfg(any(feature = "trace", feature = "os"))]
use tracing::debug;

#[cfg(feature = "trace")]
use crate::NetInfo;
#[cfg(any(feature = "trace", feature = "os"))]
use crate::error::PistolError;
#[cfg(feature = "trace")]
use crate::utils;

#[cfg(any(feature = "trace", feature = "os"))]
pub mod icmp;
#[cfg(any(feature = "trace", feature = "os"))]
pub mod icmpv6;
#[cfg(any(feature = "trace", feature = "os"))]
pub mod tcp;
#[cfg(any(feature = "trace", feature = "os"))]
pub mod tcp6;
#[cfg(any(feature = "trace", feature = "os"))]
pub mod udp;
#[cfg(any(feature = "trace", feature = "os"))]
pub mod udp6;

#[cfg(any(feature = "trace", feature = "os"))]
#[cfg(feature = "trace")]
const START_PORT: u16 = 33434;

#[cfg(any(feature = "trace", feature = "os"))]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum HopStatus {
    TimeExceeded(IpAddr),
    NoResponse,
    Unreachable(IpAddr),
    RecvReply(IpAddr),
}

#[cfg(any(feature = "trace", feature = "os"))]
#[derive(Debug, Clone, Copy)]
pub struct Trace {
    pub addr: IpAddr,
    pub hops: u8,
    pub cost: Duration,
    pub layer2_cost: Duration,
    pub start_time: DateTime<Local>,
    pub finish_time: DateTime<Local>,
}

impl Trace {
    pub(crate) fn new(addr: IpAddr) -> Self {
        let now = Local::now();
        Trace {
            addr,
            hops: 0,
            cost: Duration::ZERO,
            layer2_cost: Duration::ZERO,
            start_time: now,
            finish_time: now,
        }
    }
    pub(crate) fn finish(&mut self, hops: u8) {
        self.hops = hops;
        self.finish_time = Local::now();
    }
}

#[cfg(feature = "ping")]
impl fmt::Display for Trace {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut table = Table::new();
        table.add_row(Row::new(vec![
            Cell::new("Trace").style_spec("c").with_hspan(3),
        ]));

        table.add_row(row![
            c -> "addr",
            c -> "hops",
            c -> "time cost"
        ]);

        let addr_str = format!("{}", self.addr);
        let hops_str = format!("{}", self.hops);
        let rtt_str = utils::time_sec_to_string(self.cost);
        table.add_row(row![c -> addr_str, c -> hops_str, c -> rtt_str]);

        let summary1 = format!(
            "start at: {}, finish at: {}",
            self.start_time.format("%Y-%m-%d %H:%M:%S"),
            self.finish_time.format("%Y-%m-%d %H:%M:%S"),
        );
        let layer2_cost = self.layer2_cost.as_secs_f32();
        let summary2 = format!("layer2 cost: {:.3}s", layer2_cost);
        let summary = format!("{}\n{}", summary1, summary2);
        table.add_row(Row::new(vec![Cell::new(&summary).with_hspan(3)]));
        write!(f, "{}", table)
    }
}

/// The default target port is 80 if not specified.
#[cfg(feature = "trace")]
pub fn syn_trace(net_info: NetInfo, timeout: Duration) -> Result<Trace, PistolError> {
    let mut trace = Trace::new(net_info.dst_addr);
    let dst_mac = net_info.dst_mac;
    let dst_addr = net_info.dst_addr;
    let dst_port = if net_info.dst_ports.len() > 0 {
        net_info.dst_ports[0]
    } else {
        80
    };
    let src_mac = net_info.src_mac;
    let interface = &net_info.interface;

    match dst_addr {
        IpAddr::V4(dst_ipv4) => {
            let src_ipv4 = match net_info.src_addr {
                IpAddr::V4(src) => src,
                _ => {
                    return Err(PistolError::AttackAddressNotMatch {
                        addr: net_info.src_addr,
                    });
                }
            };

            let mut rng = rand::rng();
            let mut ip_id: u16 = rng.random();
            // ensure that this u16 does not overflow
            if ip_id >= u16::MAX - 30 {
                ip_id -= 30
            }
            let mut last_response_ttl = 0;
            for ttl in 1..=30 {
                let random_src_port = utils::random_port_range(1000, 65535);
                // let random_src_port = 61234; // debug use
                let (hop_status, rtt) = tcp::send_syn_trace_packet(
                    dst_mac,
                    dst_ipv4,
                    dst_port,
                    src_mac,
                    src_ipv4,
                    random_src_port,
                    interface,
                    ip_id,
                    ttl,
                    timeout,
                )?;
                ip_id += 1;
                match hop_status {
                    HopStatus::TimeExceeded(_) => {
                        last_response_ttl = ttl;
                    }
                    HopStatus::RecvReply(_) => {
                        // tcp rst packet, means packet arrive the target machine
                        debug!("ttl: {}, {:?} - {:.2}s", ttl, hop_status, rtt.as_secs_f64());
                        trace.finish(ttl);
                        return Ok(trace);
                    }
                    _ => (),
                }
            }
            debug!("last ttl: {}", last_response_ttl);
            trace.finish(last_response_ttl);
            Ok(trace)
        }
        IpAddr::V6(dst_ipv6) => {
            let src_ipv6 = match net_info.src_addr {
                IpAddr::V6(src) => src,
                _ => {
                    return Err(PistolError::AttackAddressNotMatch {
                        addr: net_info.src_addr,
                    });
                }
            };

            let mut last_response_hop_limit = 0;
            for hop_limit in 1..=30 {
                let random_src_port = utils::random_port_range(1000, 65535);
                let (hop_status, rtt) = tcp6::send_syn_trace_packet(
                    dst_mac,
                    dst_ipv6,
                    dst_port,
                    src_mac,
                    src_ipv6,
                    random_src_port,
                    interface,
                    hop_limit,
                    timeout,
                )?;

                match hop_status {
                    HopStatus::TimeExceeded(_) => {
                        last_response_hop_limit = hop_limit;
                    }
                    HopStatus::RecvReply(_) => {
                        debug!(
                            "hop_limit: {}, {:?} - {:.2}s",
                            hop_limit,
                            hop_status,
                            rtt.as_secs_f64()
                        );
                        // tcp rst packet, means packet arrive the target machine
                        trace.finish(hop_limit);
                        return Ok(trace);
                    }
                    _ => (),
                }
            }
            debug!("last hop limit: {}", last_response_hop_limit);
            trace.finish(last_response_hop_limit);
            Ok(trace)
        }
    }
}

#[cfg(any(feature = "trace", feature = "os"))]
pub fn icmp_trace(net_info: NetInfo, timeout: Duration) -> Result<Trace, PistolError> {
    let mut trace = Trace::new(net_info.dst_addr);
    let mut rng = rand::rng();
    let icmp_id: u16 = rng.random();

    let dst_mac = net_info.dst_mac;
    let dst_addr = net_info.dst_addr;
    let src_mac = net_info.src_mac;
    let src_addr = net_info.src_addr;
    let interface = &net_info.interface;
    match dst_addr {
        IpAddr::V4(dst_ipv4) => {
            let src_ipv4 = match src_addr {
                IpAddr::V4(src) => src,
                _ => {
                    return Err(PistolError::AttackAddressNotMatch { addr: src_addr });
                }
            };
            let mut ip_id = rng.random();
            if ip_id >= u16::MAX - 30 {
                ip_id -= 30;
            }
            let mut last_response_ttl = 0;
            for ttl in 1..=30 {
                let (hop_status, rtt) = icmp::send_icmp_trace_packet(
                    dst_mac, dst_ipv4, src_mac, src_ipv4, interface, ip_id, ttl, icmp_id,
                    ttl as u16, timeout,
                )?;
                ip_id += 1;
                match hop_status {
                    HopStatus::TimeExceeded(_) => last_response_ttl = ttl,
                    // recv echo reply, means packet arrive the target machine
                    HopStatus::RecvReply(_) => {
                        debug!("ttl: {}, {:?} - {:.2}s", ttl, hop_status, rtt.as_secs_f64());
                        trace.finish(ttl);
                        return Ok(trace);
                    }
                    _ => (),
                }
            }
            debug!("last ttl: {}", last_response_ttl);
            trace.finish(last_response_ttl);
            Ok(trace)
        }
        IpAddr::V6(dst_ipv6) => {
            let src_ipv6 = match src_addr {
                IpAddr::V6(src) => src,
                _ => {
                    return Err(PistolError::AttackAddressNotMatch { addr: src_addr });
                }
            };
            let mut last_response_hop_limit = 0;
            for hop_limit in 1..=30 {
                let (hop_status, rtt) = icmpv6::send_icmpv6_trace_packet(
                    dst_mac,
                    dst_ipv6,
                    src_mac,
                    src_ipv6,
                    interface,
                    hop_limit,
                    icmp_id,
                    hop_limit as u16,
                    timeout,
                )?;

                match hop_status {
                    HopStatus::TimeExceeded(_) => last_response_hop_limit = hop_limit,
                    // recv echo reply, means packet arrive the target machine
                    HopStatus::RecvReply(_) => {
                        debug!(
                            "hop_limit: {}, {:?} - {:.2}s",
                            hop_limit,
                            hop_status,
                            rtt.as_secs_f64()
                        );
                        trace.finish(hop_limit);
                        return Ok(trace);
                    }
                    _ => (),
                }
            }
            debug!("last hop limit: {}", last_response_hop_limit);
            trace.finish(last_response_hop_limit);
            Ok(trace)
        }
    }
}

#[cfg(feature = "trace")]
pub fn udp_trace(net_info: NetInfo, timeout: Duration) -> Result<Trace, PistolError> {
    let mut trace = Trace::new(net_info.dst_addr);
    let dst_mac = net_info.dst_mac;
    let dst_addr = net_info.dst_addr;
    let src_mac = net_info.src_mac;
    let src_addr = net_info.src_addr;
    let interface = &net_info.interface;
    match dst_addr {
        IpAddr::V4(dst_ipv4) => {
            let src_ipv4 = match src_addr {
                IpAddr::V4(src) => src,
                _ => {
                    return Err(PistolError::AttackAddressNotMatch { addr: src_addr });
                }
            };
            let mut rng = rand::rng();
            let mut ip_id: u16 = rng.random();
            if ip_id >= u16::MAX - 30 {
                ip_id -= 30;
            }
            let mut last_response_ttl = 0;
            for ttl in 1..=30 {
                let random_src_port = utils::random_port_range(1000, 65535);
                let dst_port = START_PORT + (ttl - 1) as u16;
                let (hop_status, rtt) = udp::send_udp_trace_packet(
                    dst_mac,
                    dst_ipv4,
                    dst_port,
                    src_mac,
                    src_ipv4,
                    random_src_port,
                    interface,
                    ip_id,
                    ttl,
                    timeout,
                )?;
                ip_id += 1;
                match hop_status {
                    HopStatus::TimeExceeded(_) => last_response_ttl = ttl,
                    // icmpunreachable, means packet arrive the target machine
                    HopStatus::RecvReply(_) | HopStatus::Unreachable(_) => {
                        debug!("ttl: {}, {:?} - {:.2}s", ttl, hop_status, rtt.as_secs_f64());
                        trace.finish(ttl);
                        return Ok(trace);
                    }
                    _ => (),
                }
            }
            debug!("last ttl: {}", last_response_ttl);
            trace.finish(last_response_ttl);
            Ok(trace)
        }
        IpAddr::V6(dst_ipv6) => {
            let src_ipv6 = match src_addr {
                IpAddr::V6(src) => src,
                _ => {
                    return Err(PistolError::AttackAddressNotMatch { addr: src_addr });
                }
            };
            let mut last_response_hop_limit = 0;
            for hop_limit in 1..=30 {
                let random_src_port = utils::random_port_range(1000, 65535);
                let dst_port = START_PORT + (hop_limit - 1) as u16;
                let (hop_status, rtt) = udp6::send_udp_trace_packet(
                    dst_mac,
                    dst_ipv6,
                    dst_port,
                    src_mac,
                    src_ipv6,
                    random_src_port,
                    interface,
                    hop_limit,
                    timeout,
                )?;

                match hop_status {
                    HopStatus::TimeExceeded(_) => last_response_hop_limit = hop_limit,
                    // icmpunreachable, means packet arrive the target machine
                    HopStatus::RecvReply(_) | HopStatus::Unreachable(_) => {
                        debug!(
                            "hop limit: {}, {:?} - {:.2}s",
                            hop_limit,
                            hop_status,
                            rtt.as_secs_f64()
                        );
                        trace.finish(hop_limit);
                        return Ok(trace);
                    }
                    _ => (),
                }
            }
            debug!("last hop limit: {}", last_response_hop_limit);
            trace.finish(last_response_hop_limit);
            Ok(trace)
        }
    }
}

#[cfg(feature = "trace")]
#[cfg(test)]
mod tests {
    use super::*;
    use crate::Pistol;
    use std::net::Ipv4Addr;
    use std::net::Ipv6Addr;
    use std::str::FromStr;
    #[test]
    fn test_get_hops_syn() {
        // let dst_ipv4 = Ipv4Addr::new(192, 168, 1, 3);
        // let dst_ipv4 = Ipv4Addr::new(192, 168, 5, 5);
        let dst_addr = IpAddr::V4(Ipv4Addr::new(182, 61, 244, 181));
        let dst_ports = vec![];
        let src_addr = Some(IpAddr::V4(Ipv4Addr::new(192, 168, 5, 3)));
        let src_port = None;
        let timeout = Duration::from_secs_f64(5.0);

        let mut pistol = Pistol::new();
        let (net_info, _dur) = pistol
            .init_recver_raw(dst_addr, dst_ports, src_addr, src_port)
            .unwrap();
        let trace = syn_trace(net_info, timeout).unwrap();
        println!("{}", trace);
    }
    #[test]
    fn test_get_hops_icmp() {
        // let dst_ipv4 = Ipv4Addr::new(192, 168, 1, 3);
        // let dst_ipv4 = Ipv4Addr::new(192, 168, 5, 5);
        let dst_addr = IpAddr::V4(Ipv4Addr::new(182, 61, 244, 181));
        let dst_ports = vec![];
        let src_addr = Some(IpAddr::V4(Ipv4Addr::new(192, 168, 5, 3)));
        let src_port = None;
        let timeout = Duration::from_secs_f64(5.0);

        let mut pistol = Pistol::new();
        let (net_info, _dur) = pistol
            .init_recver_raw(dst_addr, dst_ports, src_addr, src_port)
            .unwrap();
        let trace = icmp_trace(net_info, timeout).unwrap();
        println!("{}", trace);
    }
    #[test]
    fn test_get_hops_udp() {
        // let dst_ipv4 = Ipv4Addr::new(192, 168, 1, 3);
        let dst_addr = IpAddr::V4(Ipv4Addr::new(182, 61, 244, 181));
        let dst_ports = vec![];
        let src_addr = Some(IpAddr::V4(Ipv4Addr::new(192, 168, 5, 3)));
        let src_port = None;
        let timeout = Duration::from_secs_f64(5.0);

        let mut pistol = Pistol::new();
        let (net_info, _dur) = pistol
            .init_recver_raw(dst_addr, dst_ports, src_addr, src_port)
            .unwrap();
        let trace = udp_trace(net_info, timeout).unwrap();
        println!("{}", trace);
    }
    #[test]
    fn test_get_hops_udp6() {
        let dst_addr = IpAddr::V6(Ipv6Addr::from_str("fe80::20c:29ff:fe2c:9e4").unwrap());
        let dst_ports = vec![];
        let src_addr = Some(IpAddr::V6(
            Ipv6Addr::from_str("fe80::20c:29ff:fe5b:bd5c").unwrap(),
        ));
        let src_port = None;
        let timeout = Duration::from_secs_f64(5.0);

        let mut pistol = Pistol::new();
        let (net_info, _dur) = pistol
            .init_recver_raw(dst_addr, dst_ports, src_addr, src_port)
            .unwrap();
        let trace = udp_trace(net_info, timeout).unwrap();
        println!("{}", trace);
    }
}
