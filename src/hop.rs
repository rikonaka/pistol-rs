/// Code obtained by analyzing the traffic generated by the Linux `traceroute` command.
use rand::Rng;
use std::net::IpAddr;
use std::net::Ipv4Addr;
use std::net::Ipv6Addr;
use std::time::Duration;
use tracing::debug;

use crate::error::PistolError;
use crate::utils::random_port_range;

pub mod icmp;
pub mod icmpv6;
pub mod tcp;
pub mod tcp6;
pub mod udp;
pub mod udp6;

pub const UDP_DATA_SIZE: usize = 32;
const START_PORT: u16 = 33434;

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum HopStatus {
    TimeExceeded(IpAddr),
    NoResponse,
    Unreachable(IpAddr),
    RecvReply(IpAddr),
}

pub fn get_hops_tcp_syn(
    dst_ipv4: Ipv4Addr,
    dst_port: Option<u16>, // default is 80
    src_ipv4: Ipv4Addr,
    timeout: Option<Duration>,
) -> Result<u8, PistolError> {
    let mut hops = 0;
    let mut rng = rand::rng();
    let mut ip_id = rng.random();
    let dst_port = match dst_port {
        Some(p) => p,
        None => 80,
    };
    for ttl in 1..=30 {
        debug!("hops ttl: {}", ttl);
        let random_src_port = random_port_range(1000, 65535);
        let (hop_status, _rtt) = tcp::send_syn_trace_packet(
            dst_ipv4,
            dst_port,
            src_ipv4,
            random_src_port,
            ip_id,
            ttl,
            timeout,
        )?;
        ip_id += 1;
        println!("{:?}", hop_status);
        match hop_status {
            HopStatus::RecvReply(_) => return Ok(hops), // recv echo reply packet
            _ => hops += 1,
        }
    }
    Ok(0)
}

pub fn get_hops_tcp6_syn(
    dst_ipv6: Ipv6Addr,
    dst_port: Option<u16>, // default is 80
    src_ipv6: Ipv6Addr,
    timeout: Option<Duration>,
) -> Result<u8, PistolError> {
    let mut hops = 0;
    let dst_port = match dst_port {
        Some(p) => p,
        None => 80,
    };
    for hop_limit in 1..=30 {
        debug!("hops ttl: {}", hop_limit);
        let random_src_port = random_port_range(1000, 65535);
        let (hop_status, _rtt) = tcp6::send_syn_trace_packet(
            dst_ipv6,
            dst_port,
            src_ipv6,
            random_src_port,
            hop_limit,
            timeout,
        )?;
        // println!("{:?}", hop_status);
        match hop_status {
            HopStatus::RecvReply(_) => return Ok(hops), // recv echo reply packet
            _ => hops += 1,
        }
    }
    Ok(0)
}

pub fn get_hops_icmp(
    dst_ipv4: Ipv4Addr,
    src_ipv4: Ipv4Addr,
    timeout: Option<Duration>,
) -> Result<u8, PistolError> {
    let mut hops = 0;
    let mut rng = rand::rng();
    let mut ip_id = rng.random();
    let icmp_id = rng.random();
    for ttl in 1..=30 {
        debug!("hops ttl: {}", ttl);
        let (hop_status, _rtt) = icmp::send_icmp_trace_packet(
            dst_ipv4, src_ipv4, ip_id, ttl, icmp_id, ttl as u16, timeout,
        )?;
        ip_id += 1;
        // println!("{:?}", hop_status);
        match hop_status {
            HopStatus::RecvReply(_) => return Ok(hops), // recv echo reply packet
            _ => hops += 1,
        }
    }
    Ok(0)
}

pub fn get_hops_icmpv6(
    dst_ipv6: Ipv6Addr,
    src_ipv6: Ipv6Addr,
    timeout: Option<Duration>,
) -> Result<u8, PistolError> {
    let mut hops = 0;
    let mut rng = rand::rng();
    let icmp_id = rng.random();
    for hop_limit in 1..=30 {
        debug!("hops limit: {}", hop_limit);
        let (hop_status, _rtt) = icmpv6::send_icmpv6_trace_packet(
            dst_ipv6,
            src_ipv6,
            hop_limit,
            icmp_id,
            hop_limit as u16,
            timeout,
        )?;
        match hop_status {
            HopStatus::RecvReply(_) => return Ok(hops), // recv echo reply packet
            _ => hops += 1,
        }
    }
    Ok(0)
}

pub fn get_hops_udp(
    dst_ipv4: Ipv4Addr,
    src_ipv4: Ipv4Addr,
    timeout: Option<Duration>,
) -> Result<u8, PistolError> {
    let mut hops = 0;
    for ttl in 1..=30 {
        debug!("hops ttl: {}", ttl);
        let random_src_port = random_port_range(1000, 65535);
        let dst_port = START_PORT + (ttl - 1) as u16;
        let (hop_status, _rtt) = udp::send_udp_trace_packet(
            dst_ipv4,
            dst_port,
            src_ipv4,
            random_src_port,
            ttl,
            timeout,
        )?;
        match hop_status {
            HopStatus::TimeExceeded(_) => hops += 1,
            _ => return Ok(hops),
        }
    }
    Ok(0)
}

pub fn get_hops_udp6(
    dst_ipv6: Ipv6Addr,
    src_ipv6: Ipv6Addr,
    timeout: Option<Duration>,
) -> Result<u8, PistolError> {
    let mut hops = 0;
    for hop_limit in 1..=30 {
        debug!("hops limit: {}", hop_limit);
        let random_src_port = random_port_range(1000, 65535);
        let dst_port = START_PORT + (hop_limit - 1) as u16;
        let (hop_status, _rtt) = udp6::send_udp_trace_packet(
            dst_ipv6,
            dst_port,
            src_ipv6,
            random_src_port,
            hop_limit,
            timeout,
        )?;
        match hop_status {
            HopStatus::TimeExceeded(_) => hops += 1,
            _ => return Ok(hops),
        }
    }
    Ok(0)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::PistolLogger;
    use crate::PistolRunner;
    use std::str::FromStr;
    #[test]
    fn test_get_hops_tcp() {
        let _pr = PistolRunner::init(
            PistolLogger::None,
            Some(String::from("hops.pcapng")),
            None, // use default value
        )
        .unwrap();

        let dst_ipv4 = Ipv4Addr::new(192, 168, 1, 3);
        // let dst_ipv4 = Ipv4Addr::new(192, 168, 5, 5);
        // let dst_ipv4 = Ipv4Addr::new(114, 114, 114, 114);
        let src_ipv4 = Ipv4Addr::new(192, 168, 5, 3);
        let timeout = Some(Duration::from_secs_f64(0.5));
        let hops = get_hops_tcp_syn(dst_ipv4, None, src_ipv4, timeout).unwrap();
        println!("{}", hops);
    }
    #[test]
    fn test_get_hops_icmp() {
        let _pr = PistolRunner::init(
            PistolLogger::None,
            None,
            None, // use default value
        )
        .unwrap();

        let dst_ipv4 = Ipv4Addr::new(192, 168, 1, 3);
        // let dst_ipv4 = Ipv4Addr::new(192, 168, 5, 5);
        // let dst_ipv4 = Ipv4Addr::new(114, 114, 114, 114);
        let src_ipv4 = Ipv4Addr::new(192, 168, 5, 3);
        let timeout = Some(Duration::from_secs_f64(0.5));
        let hops = get_hops_icmp(dst_ipv4, src_ipv4, timeout).unwrap();
        println!("{}", hops);
    }
    #[test]
    fn test_get_hops_udp() {
        let _pr = PistolRunner::init(
            PistolLogger::None,
            None,
            None, // use default value
        )
        .unwrap();

        let dst_ipv4 = Ipv4Addr::new(192, 168, 1, 3);
        let src_ipv4 = Ipv4Addr::new(192, 168, 5, 3);
        let timeout = Some(Duration::from_secs_f64(0.5));
        let hops = get_hops_udp(dst_ipv4, src_ipv4, timeout).unwrap();
        println!("{}", hops);
    }
    #[test]
    fn test_get_hops_udp6() {
        let _pr = PistolRunner::init(
            PistolLogger::None,
            None,
            None, // use default value
        )
        .unwrap();

        let src_ipv6 = Ipv6Addr::from_str("fe80::20c:29ff:fe5b:bd5c").unwrap();
        let dst_ipv6 = Ipv6Addr::from_str("fe80::20c:29ff:fe2c:9e4").unwrap();
        let timeout = Some(Duration::from_secs_f64(0.5));
        let hops = get_hops_udp6(dst_ipv6, src_ipv6, timeout).unwrap();
        println!("{}", hops);
    }
}
